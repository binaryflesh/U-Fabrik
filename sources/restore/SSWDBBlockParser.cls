"Filed out from Dolphin Smalltalk 7"!

Object subclass: #SSWDBBlockParser
	instanceVariableNames: 'reStore argumentClass referencedTables qualifyingConditions qualifyingTables orderingSpecs'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBBlockParser guid: (GUID fromString: '{5a3e3dcf-3990-11d5-b1df-444553540000}')!
SSWDBBlockParser comment: 'Copyright 2000/2001 Solutions Software Limited'!
!SSWDBBlockParser categoriesForClass!Unclassified! !
!SSWDBBlockParser methodsFor!

argumentClass

	"21/3/2001
	
	argumentClass stores the class of object that is intended to be the single argument
	of a block being parsed by the receiver"
	
	^argumentClass!

argumentClass: aClass

	"21/3/2001
	
	argumentClass stores the class of object that is intended to be the single argument
	of a block being parsed by the receiver"
	
	argumentClass := aClass!

argumentTable

	"21/3/2001
	
	Return the SSWDBTable associated with the receiver's argumentClass"

	^self reStore tableForClass: self argumentClass!

beUnsorted

	self orderingSpecs: OrderedCollection new!

collectQueryFrom: aOneArgBlock

	"Patched for issue 120-014
	
	aOneArgBlock should be of the form [ :cd | cd releaseDate] or [ :cd | cd label name], 
	i.e. reference a Date/String/Number etc. field"
	
	| results targetFields |
	
	self reset.

	"The result of parse: will actually be an SSWDBBlockArgument
	(since the parsing is technically incomplete without a comparison).
	However if aOneArgBlock is well-formed, the finalField will be set correctly.
	If no finalField, assume we are collecting a persistent object, e.g. [ :cd | cd] or [ :cd | cd artist]"	
	results := self parse: aOneArgBlock.
	results hasFinalField
	ifTrue: 
		[targetFields := SSWSQLFieldCollection with: results finalField]
	ifFalse: 
		[self argumentClass: results currentClass.
		targetFields := SSWSQLTableAllFields forTable: self argumentTable].

	^self newSelectQuery
		fields: targetFields;
		tables: self includedTables;
		conditions: self qualifyingConditions;
		yourself!

copy

	"27/3/2001"
	
	^self shallowCopy
		qualifyingConditions: self qualifyingConditions copy;
		qualifyingTables: self qualifyingTables copy;
		orderingSpecs: self orderingSpecs copy;
		yourself!

deleteQueryFrom: aOneArgBlock

	| conditions |
	
	self reset.
	
	conditions := self parse: aOneArgBlock.
	(conditions isKindOf: SSWDBBlockEvaluator) ifTrue: [conditions := SSWSQLConditionCollection forAND].

	^SSWSQLDeleteQuery new
		tables: self includedTables;
		conditions: (conditions sqlAnd: self qualifyingConditions);
		yourself!

hasOrdering

	^self orderingSpecs isEmpty not!

includedTables

	"21/3/2001
	
	Return those tables included in the query generated by the receiver.
	This is the referencedTables, without duplicated entries"
	
	^self referencedTables withoutDuplicates!

modifyQueryFrom: aOneArgBlock

	"Patched for issue 120-009"
	
	| updates tables |
	
	self reset.
	
	updates := (self parseForModify: aOneArgBlock) asFieldAssignment.
	updates field table == self argumentTable ifFalse: [self error: 'Only single-table updates supported'].
	
	^SSWSQLUpdateQuery new
		tables: (SSWSQLTableCollection with: self argumentTable);
		fieldUpdates: updates;
		conditions: self qualifyingConditions;
		yourself!

newBlockArgument

	"21/3/2001
	
	Create and return a new SSWDBBlockArgument to parse a block with"
	
	^SSWDBBlockArgument new 
		parser: self; 
		currentClass: self argumentClass;
		yourself!

newSelectQuery

	"Return a new, initialized SelectQuery of the approriate class"

	^self hasOrdering
	ifTrue: 
		[SSWSQLOrderedSelectQuery new
			orderingSpecs: self orderingSpecs;
			yourself]
	ifFalse: 
		[SSWSQLSelectQuery new]!

orderingSpecs

	"orderingSpecs stores an OrderedCollection of SSWDBOrderingSpecs
	which are applied to all SelectQueries generated by the receiver.

	If empty, the query remains unordered"

	^orderingSpecs!

orderingSpecs: anOrderedCollection

	"orderingSpecs stores an OrderedCollection of SSWDBOrderingSpecs
	which are applied to all SelectQueries generated by the receiver.

	If empty, the query remains unordered"

	orderingSpecs := anOrderedCollection!

orWith: aBlockParser

	"'OR' the receiver with the qualifying conditions of aBlockParser"

	self qualifyingConditions: (self qualifyingConditions sqlOr: aBlockParser qualifyingConditions)
!

parse: aOneArgBlock

	"Private - 14/8/2000
	
	Parse aOneArgBlock, returning the resulting SSWSQLConditionCollection"

	^aOneArgBlock value: self newBlockArgument!

parseArgumentClassSort

	"Parse the sort criteria for the receiver, based on its implementation of <=
	NB this should only include message sends, no inst var references"

	| result implementation copy |

	self reset.

	"Make a fudged copy of the argClass implementation of <= to use with the evaluator"
	implementation := self argumentClass lookupMethod: #<=.
	implementation isNil ifTrue: [self error: ('No default sort defined for ', self argumentClass name)].
	copy := implementation copy.
	copy methodClass: SSWDBBlockEvaluator.

	result := copy value: self newBlockArgument withArguments: (Array with: DeafObject current).
	(result isKindOf: DeafObject) ifTrue:
		["Inverse sort block, e.g. [ :a :b | b name > a name]"
		copy methodClass: DeafObject.
		result := copy value: DeafObject current withArguments: (Array with: self newBlockArgument).
		result do: [ :each | each operator invert]].

	self qualifyingTables: (self qualifyingTables merge: self referencedTables withoutDuplicates).

	^result!

parseForModify: aOneArgBlock

	"Created for issue 120-009
	
	Parse aOneArgBlock, returning the resulting SSWSQLConditionCollection.
	Indicate to the parsing components that this is for a modify instruction"

	^aOneArgBlock value: (self newBlockArgument isForModify: true; yourself)!

parseSortBlock: aTwoArgBlock

	"Parse aTwoArgBlock, which should be a 'simple' sort block (see SSWDBInstancesCollection>>sortBlock)
	returning the resulting SSWSQLConditionCollection"

	| result |

	self reset.

	result := aTwoArgBlock value: self newBlockArgument value: DeafObject current.
	(result isKindOf: DeafObject) ifTrue:
		["Inverse sort block, e.g. [ :a :b | b name > a name]"
		result := aTwoArgBlock value: DeafObject current value: self newBlockArgument.
		result do: [ :each | each operator invert]].

	self qualifyingTables: (self qualifyingTables merge: self referencedTables withoutDuplicates).

	^result!

qualifyingConditions

	"27/3/01
	
	qualifyingConditions stores a static condition collection which is ANDed with 
	the conditions of any query generated by the receiver (empty by default).
	
	This enables the receiver to be used for queries focusing on a subset of a table, 
	e.g. if the receiver's qualifyingConditions were (equivalent to) [ :cd | cd label name = '4AD'],
	then the receiver could be used to focus only on CDs issued by 4AD"
	
	^qualifyingConditions!

qualifyingConditions: anSSWSQLConditionCollection

	"27/3/01
	
	qualifyingConditions stores a static condition collection which is ANDed with 
	the conditions of any query generated by the receiver (empty by default).
	
	This enables the receiver to be used for queries focusing on a subset of a table, 
	e.g. if the receiver's qualifyingConditions were (equivalent to) [ :cd | cd label name = '4AD'],
	then the receiver could be used to focus only on CDs issued by 4AD"
	
	qualifyingConditions := anSSWSQLConditionCollection!

qualifyingTables

	"27/3/01
	
	qualifyingTables stores the tables encountered when creating qualifyingConditions"
	
	^qualifyingTables!

qualifyingTables: anSSWSQLJoinedTableCollection

	"27/3/01
	
	qualifyingTables stores the tables encountered when creating qualifyingConditions"
	
	qualifyingTables := anSSWSQLJoinedTableCollection!

qualifyWith: aOneArgBlock

	"27/3/2001
	
	Set the receiver's qualifyingCondition based on aOneArgBlock"

	| parsed |

	self reset.
	
	parsed := self parse: aOneArgBlock.
	(parsed isKindOf: SSWDBBlockEvaluator) ifTrue: [parsed := parsed = true].

	self 
		qualifyingConditions: (self qualifyingConditions sqlAnd: parsed);
		qualifyingTables: (self qualifyingTables merge: self referencedTables withoutDuplicates)!

referencedTables

	"14/8/2000
	
	referencedTables stores the SSWDBTables that are referenced when parsing a block,
	in the order in which they were referenced, together with the joining fields 
	(SSWJoinedTableCollection hold both together"
	
	^referencedTables!

referencedTables: anSSWJoinedTableCollection

	"14/8/2000
	
	referencedTables stores the SSWDBTables that are referenced when parsing a block,
	in the order in which they were referenced, together with the joining fields 
	(SSWJoinedTableCollection hold both together"
	
	referencedTables := anSSWJoinedTableCollection!

rejectQueryFrom: aOneArgBlock

	"23/3/2001"
	
	| conditions |
	
	self reset.
	
	"Invert (not) the parse: result to turn select into reject"
	conditions := (self parse: aOneArgBlock) not.

	^self newSelectQuery
		fields: (SSWSQLTableAllFields forTable: self argumentTable);
		tables: self includedTables;
		conditions: (conditions sqlAnd: self qualifyingConditions);
		yourself!

reset

	"Private - 23/3/2001
	
	Reset the receiver for a new parsing session"
	
	self referencedTables: (SSWSQLLeftJoinedTableCollection with: self argumentTable).
	
	self qualifyingTables isNil ifFalse: [self referencedTables merge: self qualifyingTables]!

reStore

	"14/8/2000
	
	reStore stores the SSWReStore for which the receiver parses blocks"
	
	^reStore!

reStore: anSSWReStore

	"14/8/2000
	
	reStore stores the SSWReStore for which the receiver parses blocks"
	
	reStore := anSSWReStore!

selectQueryFrom: aOneArgBlock

	"14/8/2000"
	
	| conditions |
	
	self reset.
	
	conditions := self parse: aOneArgBlock.

	^self newSelectQuery
		fields: (SSWSQLTableAllFields forTable: self argumentTable);
		tables: self includedTables;
		conditions: (conditions sqlAnd: self qualifyingConditions);
		yourself!

sortBlock: aTwoArgBlock

	| sortConditions |

	[aTwoArgBlock == SortedCollection	"Default <= implementation"
		ifTrue: [sortConditions := self parseArgumentClassSort]
		ifFalse: [sortConditions := self parseSortBlock: aTwoArgBlock]] 
			on:	SSWDBParseError
			do:	[ :error | 
				error isFinalFieldError
					ifTrue: [error resume: nil]
					ifFalse: [error pass]].

	"For SQL ordering we require a flat collection. Also equality conditions are ignored.
	Thus (e.g.) 
		(p1 surname < p2 surname) | ((p1 surname = p2 surname) & (p1 firstName < p2 firstName))
	becomes:
		order by SURNAME asc, FIRST_NAME asc"
	sortConditions := sortConditions flattened reject: [ :each | each operator messageSelector = #=].

	self orderingSpecs: (sortConditions collect: [ :each | each asOrderingSpec])! !
!SSWDBBlockParser categoriesFor: #argumentClass!accessing!public! !
!SSWDBBlockParser categoriesFor: #argumentClass:!accessing!public! !
!SSWDBBlockParser categoriesFor: #argumentTable!evaluating!public! !
!SSWDBBlockParser categoriesFor: #beUnsorted!parsing - api!public! !
!SSWDBBlockParser categoriesFor: #collectQueryFrom:!parsing - api!public! !
!SSWDBBlockParser categoriesFor: #copy!evaluating!public! !
!SSWDBBlockParser categoriesFor: #deleteQueryFrom:!parsing - api!public! !
!SSWDBBlockParser categoriesFor: #hasOrdering!public!testing! !
!SSWDBBlockParser categoriesFor: #includedTables!evaluating!public! !
!SSWDBBlockParser categoriesFor: #modifyQueryFrom:!parsing - api!public! !
!SSWDBBlockParser categoriesFor: #newBlockArgument!evaluating!public! !
!SSWDBBlockParser categoriesFor: #newSelectQuery!evaluating!public! !
!SSWDBBlockParser categoriesFor: #orderingSpecs!accessing!public! !
!SSWDBBlockParser categoriesFor: #orderingSpecs:!accessing!public! !
!SSWDBBlockParser categoriesFor: #orWith:!parsing - api!public! !
!SSWDBBlockParser categoriesFor: #parse:!parsing - internal!private! !
!SSWDBBlockParser categoriesFor: #parseArgumentClassSort!parsing - internal!private! !
!SSWDBBlockParser categoriesFor: #parseForModify:!public! !
!SSWDBBlockParser categoriesFor: #parseSortBlock:!parsing - internal!private! !
!SSWDBBlockParser categoriesFor: #qualifyingConditions!accessing!public! !
!SSWDBBlockParser categoriesFor: #qualifyingConditions:!accessing!public! !
!SSWDBBlockParser categoriesFor: #qualifyingTables!accessing!public! !
!SSWDBBlockParser categoriesFor: #qualifyingTables:!accessing!public! !
!SSWDBBlockParser categoriesFor: #qualifyWith:!parsing - api!public! !
!SSWDBBlockParser categoriesFor: #referencedTables!accessing!public! !
!SSWDBBlockParser categoriesFor: #referencedTables:!accessing!public! !
!SSWDBBlockParser categoriesFor: #rejectQueryFrom:!parsing - api!public! !
!SSWDBBlockParser categoriesFor: #reset!parsing - internal!private! !
!SSWDBBlockParser categoriesFor: #reStore!accessing!public! !
!SSWDBBlockParser categoriesFor: #reStore:!accessing!public! !
!SSWDBBlockParser categoriesFor: #selectQueryFrom:!parsing - api!public! !
!SSWDBBlockParser categoriesFor: #sortBlock:!parsing - api!public! !

!SSWDBBlockParser class methodsFor!

new

	"21/3/2001"
	
	^super new
		qualifyingConditions: SSWSQLConditionCollection forAND;
		qualifyingTables: SSWSQLLeftJoinedTableCollection new;
		orderingSpecs: OrderedCollection new;
		yourself!

newForReStore: anSSWReStore argumentClass: aClass

	"21/3/2001"
	
	^self new
		reStore: anSSWReStore;
		argumentClass: aClass;
		yourself! !
!SSWDBBlockParser class categoriesFor: #new!instance creation!public! !
!SSWDBBlockParser class categoriesFor: #newForReStore:argumentClass:!instance creation!public! !

